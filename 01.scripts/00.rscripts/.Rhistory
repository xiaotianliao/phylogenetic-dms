if (startsWith(fasta_lines[j], ">")) break
seq_lines <- c(seq_lines, fasta_lines[j])
}
# Collapse sequence lines into a single string
sequence <- paste(seq_lines, collapse = "")
return(sequence)
}
return(NA)
}
# Iterate through each row in the CSV and check for motifs in the FASTA sequence
for (i in 1:nrow(csv_data)) {
label <- csv_data$tree.tip.label[i]
simplified_label <- extract_header(label)  # Extract relevant part
sequence <- get_sequence_for_header(simplified_label)
if (!is.na(sequence)) {
# Check for N-terminal motif 'GEEDIPR'
if (grepl("GEEDIPR", sequence)) {
csv_data$N_terminal_extension[i] <- TRUE
}
# Check for C-terminal motif 'EYSRFEA'
if (grepl("EYSRFEA", sequence)) {
csv_data$C_terminal_extension[i] <- TRUE
}
}
}
csv_data
# Save the updated CSV file
write.csv(csv_data, "/Users/xl7/Documents/0.Projects/02.phylo-dms/00.inputs/06.dlg4_blastp/mafft_web_processed/extension.csv", row.names = FALSE)
csv_data[csv_data$N_terminal_extension==TRUE,]
csv_data[csv_data$N_terminal_extension==TRUE]
unique(csv_data$N_terminal_extension)
unique(csv_data$C_terminal_extension)
# Iterate through each row in the CSV and check for motifs in the FASTA sequence
for (i in 1:nrow(csv_data)) {
label <- csv_data$tree.tip.label[i]
simplified_label <- extract_header(label)  # Extract relevant part
sequence <- get_sequence_for_header(simplified_label)
if (!is.na(sequence)) {
# Check for N-terminal motif 'GEEDIPR'
if (grepl("GEEDIP", sequence)) {
csv_data$N_terminal_extension[i] <- TRUE
}
# Check for C-terminal motif 'EYSRFEA'
if (grepl("EYSRFEA", sequence)) {
csv_data$C_terminal_extension[i] <- TRUE
}
}
}
csv_data
unique(csv_data$N_terminal_extension)
unique(csv_data$C_terminal_extension)
csv_data$tree.tip.label
extract_header(csv_data$tree.tip.label[0])
extract_header <- function(label) {
# Remove the initial numeric prefix and underscores
label <- sub("^[^_]*_", "", label)  # Remove leading "1_"
# Replace the first two underscores between the accession number and version with a dot and colon
label <- sub("_(\\d+)_", ".\\1:", label)
# Replace double underscores before the species name with space and an open bracket
label <- sub("__", " [", label)
# Replace underscores in the species name with spaces
label <- sub("_(\\w+)_", " \\1", label)
# Remove any trailing underscores in the species name and add closing bracket
label <- sub("_$", "]", label)
return(label)
}
extract_header(csv_data$tree.tip.label[0])
csv_data$tree.tip.label[0]
extract_header(csv_data$tree.tip.label[1])
extract_header(csv_data$tree.tip.label[1])
get_sequence_for_header(extract_header(csv_data$tree.tip.label[1]))
get_sequence_for_header(extract_header(csv_data$tree.tip.label[1]))
# Modify get_sequence_for_header to match the new header format and escape special characters
get_sequence_for_header <- function(header) {
header_line <- grep(paste0(">", header), fasta_lines)
if (length(header_line) > 0) {
# Collect all sequence lines until the next header or end of file
seq_lines <- character(0)
for (j in (header_line + 1):length(fasta_lines)) {
if (startsWith(fasta_lines[j], ">")) break
seq_lines <- c(seq_lines, fasta_lines[j])
}
# Collapse sequence lines into a single string
sequence <- paste(seq_lines, collapse = "")
return(sequence)
}
return(NA)
}
get_sequence_for_header(extract_header(csv_data$tree.tip.label[1]))
get_sequence_for_header(csv_data$tree.tip.label[1])
extract_header <- function(label) {
# Remove the initial numeric prefix and underscores
label <- sub("^[^_]*_", "", label)  # Remove leading "1_"
# Replace the first underscore after accession number with a dot (version number)
label <- sub("_(\\d+)_", ".\\1:", label)
# Replace double underscores before species name with " [" and add closing bracket
label <- sub("__", " [", label)
# Replace underscores in species name with spaces and close the bracket
label <- sub("_(\\w+)_", " \\1", label)
# Ensure the species name closes with a bracket
label <- sub("_$", "]", label)
return(label)
}
# Test the function on a sample header
header <- csv_data$tree.tip.label[1]
print(header)  # Original tree label
print(extract_header(header))  # Simplified header for FASTA matching
# Modify get_sequence_for_header to match the new header format and escape special characters
get_sequence_for_header <- function(header) {
# Escape special characters in the header string
header <- gsub("([][])", "\\\\\\1", header)  # Escape square brackets [ and ]
header <- gsub("\\.", "\\\\.", header)       # Escape dots in the header
# Now use the escaped header in the search
header_line <- grep(paste0(">", header), fasta_lines)
if (length(header_line) > 0) {
# Collect all sequence lines until the next header or end of file
seq_lines <- character(0)
for (j in (header_line + 1):length(fasta_lines)) {
if (startsWith(fasta_lines[j], ">")) break
seq_lines <- c(seq_lines, fasta_lines[j])
}
# Collapse sequence lines into a single string
sequence <- paste(seq_lines, collapse = "")
return(sequence)
}
return(NA)
}
# Iterate through each row in the CSV and check for motifs in the FASTA sequence
for (i in 1:nrow(csv_data)) {
label <- csv_data$Label.x[i]
sequence <- get_sequence_for_header(label)
if (!is.na(sequence)) {
# Check for N-terminal motif 'GEEDIPR'
if (str_detect(sequence, "GEEDIP")) {
csv_data$N_terminal_extension[i] <- TRUE
}
# Check for C-terminal motif 'EYSRFEA'
if (str_detect(sequence, "EYSRFEA")) {
csv_data$C_terminal_extension[i] <- TRUE
}
}
}
unique(csv_data$N_terminal_extension)
get_sequence_for_header(csv_data$tree.tip.label[1])
get_sequence_for_header(csv_data$tree.tip.label[10])
csv_data
unique(csv_data$N_terminal_extension)
# Test the header extraction and sequence fetching
header <- csv_data$tree.tip.label[1]
simplified_label <- extract_header(header)
sequence <- get_sequence_for_header(simplified_label)
# Output results
print(simplified_label)
print(sequence)
extract_header <- function(label) {
# Remove the initial numeric prefix and underscores
label <- sub("^[^_]*_", "", label)  # Remove leading "1_"
# Replace the underscore before the version with a dot and colon (ensure it's not NP.)
label <- sub("_(\\d+)_", ".\\1:", label)
# Ensure the phrase "isoform 4" is formatted correctly (with a space)
label <- sub("isoform(\\d)", "isoform \\1", label)
# Replace double underscores before species name with space and an open bracket
label <- sub("__", " [", label)
# Replace underscores in the species name with spaces
label <- sub("_(\\w+)_", " \\1", label)
# Add closing bracket after the species name
label <- sub("_$", "]", label)
return(label)
}
# Test the function on a sample header
header <- csv_data$tree.tip.label[1]
print(header)  # Original tree label
print(extract_header(header))  # Simplified header for FASTA matching
extract_header <- function(label) {
# Remove the initial numeric prefix and underscores
label <- sub("^[^_]*_", "", label)  # Remove leading numeric prefix
# Correctly format accession number with a dot between accession and version
label <- sub("_(\\d+)_(\\d+)", ".\\1:\\2", label)
# Ensure the phrase "isoform 4" is formatted correctly (with a space)
label <- sub("isoform(\\d)", "isoform \\1", label)
# Replace double underscores before species name with space and an open bracket
label <- sub("__", " [", label)
# Replace underscores in the species name with spaces (handle multiple words)
label <- gsub("_(\\w)", " \\1", label)
# Add closing bracket after the species name
label <- sub("_$", "]", label)
return(label)
}
# Test this function on a sample header
header <- csv_data$tree.tip.label[1]
print(header)  # Original tree label
print(extract_header(header))  # Simplified header for FASTA matching
# Modify get_sequence_for_header to match the new header format and escape special characters
get_sequence_for_header <- function(header) {
# Escape special characters in the header string
header <- gsub("([][])", "\\\\\\1", header)  # Escape square brackets [ and ]
header <- gsub("\\.", "\\\\.", header)       # Escape dots in the header
# Now use the escaped header in the search
header_line <- grep(paste0(">", header), fasta_lines)
if (length(header_line) > 0) {
# Collect all sequence lines until the next header or end of file
seq_lines <- character(0)
for (j in (header_line + 1):length(fasta_lines)) {
if (startsWith(fasta_lines[j], ">")) break
seq_lines <- c(seq_lines, fasta_lines[j])
}
# Collapse sequence lines into a single string
sequence <- paste(seq_lines, collapse = "")
return(sequence)
}
return(NA)
}
# Test the header extraction and sequence fetching
header <- csv_data$tree.tip.label[1]
simplified_label <- extract_header(header)
sequence <- get_sequence_for_header(simplified_label)
# Output results
print(simplified_label)
print(sequence)
# Modify get_sequence_for_header to match the new header format and escape special characters
get_sequence_for_header <- function(header) {
# Escape special characters in the header string
#header <- gsub("([][])", "\\\\\\1", header)  # Escape square brackets [ and ]
#header <- gsub("\\.", "\\\\.", header)       # Escape dots in the header
# Now use the escaped header in the search
header_line <- grep(paste0(">", header), fasta_lines)
if (length(header_line) > 0) {
# Collect all sequence lines until the next header or end of file
seq_lines <- character(0)
for (j in (header_line + 1):length(fasta_lines)) {
if (startsWith(fasta_lines[j], ">")) break
seq_lines <- c(seq_lines, fasta_lines[j])
}
# Collapse sequence lines into a single string
sequence <- paste(seq_lines, collapse = "")
return(sequence)
}
return(NA)
}
# Test the header extraction and sequence fetching
header <- csv_data$tree.tip.label[1]
simplified_label <- extract_header(header)
sequence <- get_sequence_for_header(simplified_label)
# Output results
print(simplified_label)
print(sequence)
annotation_data <- data.frame(
species = midpoint_tree$tip.label,  # Tip labels from your tree
clade = ifelse(midpoint_tree$tip.label %in% dlg1_tips, "DLG1",
ifelse(midpoint_tree$tip.label %in% dlg2_tips, "DLG2",
ifelse(midpoint_tree$tip.label %in% dlg3_tips, "DLG3", "DLG4")))
)
# Convert the clade column into a factor for easy visualization
annotation_data$clade <- as.factor(annotation_data$clade)
nrow(annotation_data)
annotation_data
p1 <- gheatmap(p, annotation_data[, "clade", drop=FALSE],
offset = 0.01, width = 0.05, colnames_angle = 90, colnames_offset_y = 0.5,
colnames = FALSE) +
scale_fill_viridis_d(option="D",  name = "Clade")
p1
# Check the number of rows in annotation_data and the tree
print(nrow(annotation_data))  # This should match the number of tip labels in the tree
print(length(tree$tip.label))  # Compare with this to ensure consistency
tree <- drop.tip(tree, extra_tips)
print(length(tree$tip.label))
# Filter `annotation_data` to include only matching species in the tree
annotation_data_filtered <- annotation_data[annotation_data$species %in% tree$tip.label, ]
annotation_data_filtered
p1 <- gheatmap(p, annotation_data_filtered[, "clade", drop=FALSE],
offset = 0.01, width = 0.05, colnames_angle = 90, colnames_offset_y = 0.5,
colnames = FALSE) +
scale_fill_viridis_d(option="D",  name = "Clade")
p1
rownames(annotation_data) <- annotation_data$species
rownames(annotation_data)
p1 <- gheatmap(p, annotation_data[, "clade", drop=FALSE],
offset = 0.01, width = 0.05, colnames_angle = 90, colnames_offset_y = 0.5,
colnames = FALSE) +
scale_fill_viridis_d(option="D",  name = "Clade")
p1
# Test the header extraction and sequence fetching
header <- csv_data$tree.tip.label[1]
simplified_label <- extract_header(header)
sequence <- get_sequence_for_header(simplified_label)
# Output results
print(simplified_label)
# Function to extract the NCBI ID from the tree tip label
extract_ncbi_id <- function(label) {
# Extract the NCBI ID from the label (e.g., NP_001308004)
match <- regmatches(label, regexpr("NP_[0-9]+|XP_[0-9]+|AAH[0-9]+|KAF[0-9]+", label))
return(match)
}
# Modify get_sequence_for_header to match the NCBI ID only (partial match)
get_sequence_for_ncbi_id <- function(ncbi_id) {
# Perform a partial match using the NCBI ID (e.g., NP_001308004)
header_line <- grep(paste0(">", ncbi_id), fasta_lines)
if (length(header_line) > 0) {
# Collect all sequence lines until the next header or end of file
seq_lines <- character(0)
for (j in (header_line + 1):length(fasta_lines)) {
if (startsWith(fasta_lines[j], ">")) break
seq_lines <- c(seq_lines, fasta_lines[j])
}
# Collapse sequence lines into a single string
sequence <- paste(seq_lines, collapse = "")
return(sequence)
}
return(NA)
}
# Test the header extraction and sequence fetching
header <- csv_data$tree.tip.label[1]
ncbi_id <- extract_ncbi_id(header)
sequence <- get_sequence_for_ncbi_id(ncbi_id)
# Output results
print(ncbi_id)
print(sequence)
# Test the header extraction and sequence fetching
header <- csv_data$tree.tip.label[10]
ncbi_id <- extract_ncbi_id(header)
sequence <- get_sequence_for_ncbi_id(ncbi_id)
# Output results
print(ncbi_id)
print(sequence)
# Iterate through each row in the CSV, extract NCBI ID, check motifs, and update CSV
for (i in 1:nrow(csv_data)) {
label <- csv_data$tree.tip.label[i]
ncbi_id <- extract_ncbi_id(label)  # Extract NCBI ID
if (!is.na(ncbi_id)) {
sequence <- get_sequence_for_ncbi_id(ncbi_id)  # Get the sequence for the NCBI ID
if (!is.na(sequence)) {
# Check for N-terminal motif 'GEEDIPR'
if (grepl("GEEDIP", sequence)) {
csv_data$N_terminal_extension[i] <- TRUE
}
# Check for C-terminal motif 'EYSRFEA'
if (grepl("EYSRFEA", sequence)) {
csv_data$C_terminal_extension[i] <- TRUE
}
}
}
}
# Iterate through each row in the CSV, extract NCBI ID, check motifs, and update CSV
for (i in 1:nrow(csv_data)) {
label <- csv_data$tree.tip.label[i]
ncbi_id <- extract_ncbi_id(label)  # Extract NCBI ID
if (!is.na(ncbi_id)) {
sequence <- get_sequence_for_ncbi_id(ncbi_id)  # Get the sequence for the NCBI ID
if (!is.na(sequence)) {
# Check for N-terminal motif 'GEEDIPR'
if (grepl("GEEDI", sequence)) {
csv_data$N_terminal_extension[i] <- TRUE
}
# Check for C-terminal motif 'EYSRFEA'
if (grepl("EYSRFEA", sequence)) {
csv_data$C_terminal_extension[i] <- TRUE
}
}
}
}
# Function to extract the NCBI ID from the tree tip label
extract_ncbi_id <- function(label) {
# Extract the NCBI ID (e.g., NP_001308004, XP_010613106)
match <- regmatches(label, regexpr("NP_[0-9]+|XP_[0-9]+|AAH[0-9]+|KAF[0-9]+", label))
if (length(match) > 0) {
return(match)
} else {
return(NA)
}
}
# Modify get_sequence_for_header to match the NCBI ID only (partial match)
get_sequence_for_ncbi_id <- function(ncbi_id) {
# Perform a partial match using the NCBI ID (e.g., NP_001308004)
header_line <- grep(paste0(">", ncbi_id), fasta_lines)
if (length(header_line) > 0) {
# Collect all sequence lines until the next header or end of file
seq_lines <- character(0)
for (j in (header_line + 1):length(fasta_lines)) {
if (startsWith(fasta_lines[j], ">")) break
seq_lines <- c(seq_lines, fasta_lines[j])
}
# Collapse sequence lines into a single string
sequence <- paste(seq_lines, collapse = "")
return(sequence)
}
return(NA)
}
# Test the header extraction and sequence fetching
header <- csv_data$tree.tip.label[10]
ncbi_id <- extract_ncbi_id(header)
sequence <- get_sequence_for_ncbi_id(ncbi_id)
# Output results
print(ncbi_id)
print(sequence)
# Iterate through each row in the CSV, extract NCBI ID, check motifs, and update CSV
for (i in 1:nrow(csv_data)) {
label <- csv_data$tree.tip.label[i]
ncbi_id <- extract_ncbi_id(label)  # Extract NCBI ID
if (!is.na(ncbi_id)) {
sequence <- get_sequence_for_ncbi_id(ncbi_id)  # Get the sequence for the NCBI ID
if (!is.na(sequence)) {
# Check for N-terminal motif 'GEEDIPR'
if (grepl("GEEDI", sequence)) {
csv_data$N_terminal_extension[i] <- TRUE
}
# Check for C-terminal motif 'EYSRFEA'
if (grepl("EYSRFEA", sequence)) {
csv_data$C_terminal_extension[i] <- TRUE
}
}
}
}
unique(csv_data$N_terminal_extension)
csv_data
unique(csv_data$C_terminal_extension)
# Initialize columns for N-terminal and C-terminal extension
csv_data$N_terminal_extension <- FALSE
csv_data$C_terminal_extension <- FALSE
# Function to extract the NCBI ID from the tree tip label
extract_ncbi_id <- function(label) {
# Extract the NCBI ID (e.g., NP_001308004, XP_010613106)
match <- regmatches(label, regexpr("NP_[0-9]+|XP_[0-9]+|AAH[0-9]+|KAF[0-9]+", label))
if (length(match) > 0) {
return(match)
} else {
return(NA)
}
}
# Modify get_sequence_for_header to match the NCBI ID only (partial match)
get_sequence_for_ncbi_id <- function(ncbi_id) {
# Perform a partial match using the NCBI ID (e.g., NP_001308004)
header_line <- grep(paste0(">", ncbi_id), fasta_lines)
if (length(header_line) > 0) {
# Collect all sequence lines until the next header or end of file
seq_lines <- character(0)
for (j in (header_line + 1):length(fasta_lines)) {
if (startsWith(fasta_lines[j], ">")) break
seq_lines <- c(seq_lines, fasta_lines[j])
}
# Collapse sequence lines into a single string
sequence <- paste(seq_lines, collapse = "")
return(sequence)
}
return(NA)
}
# Test the header extraction and sequence fetching
header <- csv_data$tree.tip.label[10]
ncbi_id <- extract_ncbi_id(header)
sequence <- get_sequence_for_ncbi_id(ncbi_id)
# Output results
print(ncbi_id)
print(sequence)
# Iterate through each row in the CSV, extract NCBI ID, check motifs, and update CSV
for (i in 1:nrow(csv_data)) {
label <- csv_data$tree.tip.label[i]
ncbi_id <- extract_ncbi_id(label)  # Extract NCBI ID
if (!is.na(ncbi_id)) {
sequence <- get_sequence_for_ncbi_id(ncbi_id)  # Get the sequence for the NCBI ID
if (!is.na(sequence)) {
# Check for N-terminal motif 'GEEDIPR'
if (grepl("GEEDIP", sequence)) {
csv_data$N_terminal_extension[i] <- TRUE
}
# Check for C-terminal motif 'EYSRFEA'
if (grepl("EYSRFEA", sequence)) {
csv_data$C_terminal_extension[i] <- TRUE
}
}
}
}
unique(csv_data$N_terminal_extension)
unique(csv_data$C_terminal_extension)
# Save the updated CSV file
output_csv <- "/Users/xl7/Documents/0.Projects/02.phylo-dms/00.inputs/06.dlg4_blastp/mafft_web_processed/extension.csv"
write.csv(csv_data, output_csv, row.names = FALSE)
nrow(csv_data)
rownames(csv_data) <- csv_data$tree.tip.label
annotation_data <- data.frame(
species = midpoint_tree$tip.label,  # Tip labels from your tree
clade = ifelse(midpoint_tree$tip.label %in% dlg1_tips, "DLG1",
ifelse(midpoint_tree$tip.label %in% dlg2_tips, "DLG2",
ifelse(midpoint_tree$tip.label %in% dlg3_tips, "DLG3", "DLG4"))),
N_terminal_extension = csv_data$N_terminal_extension,  # Use appropriate data
C_terminal_extension = csv_data$C_terminal_extension   # Use appropriate data
)
rownames(annotation_data) <- annotation_data$species
annotation_data$clade <- as.factor(annotation_data$clade)
nrow(annotation_data)
p1 <- gheatmap(p, annotation_data_filtered[, "clade", drop=FALSE],
offset = 0.01, width = 0.05, colnames_angle = 90, colnames_offset_y = 0.5,
colnames = FALSE) +
scale_fill_viridis_d(option="D",  name = "Clade")
p1
p1 <- gheatmap(p, annotation_data[, "clade", drop=FALSE],
offset = 0.01, width = 0.05, colnames_angle = 90, colnames_offset_y = 0.5,
colnames = FALSE) +
scale_fill_viridis_d(option="D",  name = "Clade")
p1
p2 <- p1 + new_scale_fill()
p2 <- gheatmap(p2, annotation_data[, "N_terminal_extension", drop = FALSE],
offset = 3, width = 0.05, colnames_angle = 90, colnames_offset_y = 0.5,
colnames = FALSE) +
scale_fill_viridis_d(option="G",  name = "N-terminal Extension")
p2
p3 <- p2 + new_scale_fill()
p3 <- gheatmap(p3, annotation_data[, "C_terminal_extension", drop = FALSE],
offset = 6, width = 0.05, colnames_angle = 90, colnames_offset_y = 0.5,
colnames = FALSE) +
scale_fill_viridis_d(option="G",  name = "C-terminal Extension")
p3
p2
p3
